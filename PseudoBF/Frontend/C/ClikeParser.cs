//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.1 D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g 2013-03-01 19:23:28

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.1")]
[System.CLSCompliant(false)]
public partial class ClikeParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ADD", "AND", "ARRDEF", "ASSIGN", "CHARLIT", "COMMENT", "EQ", "EXPRLIST", "FUNCALL", "FUNCDECL", "FUNCDEF", "GT", "ID", "IDLIST", "IF", "LT", "MUL", "NEQ", "NOT", "NUMBER", "OR", "PROGRAM", "RETURN", "STANDALONE", "STATLIST", "SUB", "VARDEF", "VARNAME", "WHILE", "WHITESPACE", "'('", "')'", "','", "';'", "'['", "']'", "'extern'", "'func'", "'if'", "'return'", "'var'", "'while'", "'{'", "'}'"
	};
	public const int EOF=-1;
	public const int ADD=4;
	public const int AND=5;
	public const int ARRDEF=6;
	public const int ASSIGN=7;
	public const int CHARLIT=8;
	public const int COMMENT=9;
	public const int EQ=10;
	public const int EXPRLIST=11;
	public const int FUNCALL=12;
	public const int FUNCDECL=13;
	public const int FUNCDEF=14;
	public const int GT=15;
	public const int ID=16;
	public const int IDLIST=17;
	public const int IF=18;
	public const int LT=19;
	public const int MUL=20;
	public const int NEQ=21;
	public const int NOT=22;
	public const int NUMBER=23;
	public const int OR=24;
	public const int PROGRAM=25;
	public const int RETURN=26;
	public const int STANDALONE=27;
	public const int STATLIST=28;
	public const int SUB=29;
	public const int VARDEF=30;
	public const int VARNAME=31;
	public const int WHILE=32;
	public const int WHITESPACE=33;
	public const int T__34=34;
	public const int T__35=35;
	public const int T__36=36;
	public const int T__37=37;
	public const int T__38=38;
	public const int T__39=39;
	public const int T__40=40;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int T__46=46;
	public const int T__47=47;

	public ClikeParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public ClikeParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return ClikeParser.tokenNames; } }
	public override string GrammarFileName { get { return "D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();
	// $ANTLR start "program"
	// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:13:8: public program : ( fdef )+ EOF -> ^( PROGRAM ( fdef )+ ) ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<object, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EOF2 = default(IToken);
		AstParserRuleReturnScope<object, IToken> fdef1 = default(AstParserRuleReturnScope<object, IToken>);

		object EOF2_tree = default(object);
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_fdef=new RewriteRuleSubtreeStream(adaptor,"rule fdef");
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(13, 61);
		try
		{
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:13:15: ( ( fdef )+ EOF -> ^( PROGRAM ( fdef )+ ) )
			DebugEnterAlt(1);
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:13:17: ( fdef )+ EOF
			{
			DebugLocation(13, 17);
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:13:17: ( fdef )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if (((LA1_1>=40 && LA1_1<=41)))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:13:17: fdef
					{
					DebugLocation(13, 17);
					PushFollow(Follow._fdef_in_program170);
					fdef1=fdef();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_fdef.Add(fdef1.Tree);

					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(13, 23);
			EOF2=(IToken)Match(input,EOF,Follow._EOF_in_program173); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOF.Add(EOF2);



			{
			// AST REWRITE
			// elements: fdef
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 13:43: -> ^( PROGRAM ( fdef )+ )
			{
				DebugLocation(13, 46);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:13:46: ^( PROGRAM ( fdef )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(13, 48);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PROGRAM, "PROGRAM"), root_1);

				DebugLocation(13, 56);
				if (!(stream_fdef.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_fdef.HasNext )
				{
					DebugLocation(13, 56);
					adaptor.AddChild(root_1, stream_fdef.NextTree());

				}
				stream_fdef.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(13, 61);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_fdef();
	partial void LeaveRule_fdef();
	// $ANTLR start "fdef"
	// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:14:1: fdef : ( 'func' ID idlist stat -> ^( FUNCDEF ID idlist stat ) | 'extern' ID idlist ';' -> ^( FUNCDECL ID idlist ) );
	[GrammarRule("fdef")]
	private AstParserRuleReturnScope<object, IToken> fdef()
	{
		EnterRule_fdef();
		EnterRule("fdef", 2);
		TraceIn("fdef", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal3 = default(IToken);
		IToken ID4 = default(IToken);
		IToken string_literal7 = default(IToken);
		IToken ID8 = default(IToken);
		IToken char_literal10 = default(IToken);
		AstParserRuleReturnScope<object, IToken> idlist5 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> stat6 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> idlist9 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal3_tree = default(object);
		object ID4_tree = default(object);
		object string_literal7_tree = default(object);
		object ID8_tree = default(object);
		object char_literal10_tree = default(object);
		RewriteRuleITokenStream stream_41=new RewriteRuleITokenStream(adaptor,"token 41");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_40=new RewriteRuleITokenStream(adaptor,"token 40");
		RewriteRuleITokenStream stream_37=new RewriteRuleITokenStream(adaptor,"token 37");
		RewriteRuleSubtreeStream stream_idlist=new RewriteRuleSubtreeStream(adaptor,"rule idlist");
		RewriteRuleSubtreeStream stream_stat=new RewriteRuleSubtreeStream(adaptor,"rule stat");
		try { DebugEnterRule(GrammarFileName, "fdef");
		DebugLocation(14, 66);
		try
		{
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:14:5: ( 'func' ID idlist stat -> ^( FUNCDEF ID idlist stat ) | 'extern' ID idlist ';' -> ^( FUNCDECL ID idlist ) )
			int alt2=2;
			try { DebugEnterDecision(2, false);
			int LA2_1 = input.LA(1);

			if ((LA2_1==41))
			{
				alt2 = 1;
			}
			else if ((LA2_1==40))
			{
				alt2 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:14:7: 'func' ID idlist stat
				{
				DebugLocation(14, 7);
				string_literal3=(IToken)Match(input,41,Follow._41_in_fdef204); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_41.Add(string_literal3);

				DebugLocation(14, 14);
				ID4=(IToken)Match(input,ID,Follow._ID_in_fdef206); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID4);

				DebugLocation(14, 17);
				PushFollow(Follow._idlist_in_fdef208);
				idlist5=idlist();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_idlist.Add(idlist5.Tree);
				DebugLocation(14, 24);
				PushFollow(Follow._stat_in_fdef210);
				stat6=stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_stat.Add(stat6.Tree);


				{
				// AST REWRITE
				// elements: ID, idlist, stat
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 14:43: -> ^( FUNCDEF ID idlist stat )
				{
					DebugLocation(14, 46);
					// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:14:46: ^( FUNCDEF ID idlist stat )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(14, 48);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCDEF, "FUNCDEF"), root_1);

					DebugLocation(14, 56);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(14, 59);
					adaptor.AddChild(root_1, stream_idlist.NextTree());
					DebugLocation(14, 66);
					adaptor.AddChild(root_1, stream_stat.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:15:7: 'extern' ID idlist ';'
				{
				DebugLocation(15, 7);
				string_literal7=(IToken)Match(input,40,Follow._40_in_fdef244); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_40.Add(string_literal7);

				DebugLocation(15, 16);
				ID8=(IToken)Match(input,ID,Follow._ID_in_fdef246); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID8);

				DebugLocation(15, 19);
				PushFollow(Follow._idlist_in_fdef248);
				idlist9=idlist();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_idlist.Add(idlist9.Tree);
				DebugLocation(15, 26);
				char_literal10=(IToken)Match(input,37,Follow._37_in_fdef250); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_37.Add(char_literal10);



				{
				// AST REWRITE
				// elements: ID, idlist
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 15:43: -> ^( FUNCDECL ID idlist )
				{
					DebugLocation(15, 46);
					// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:15:46: ^( FUNCDECL ID idlist )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(15, 48);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCDECL, "FUNCDECL"), root_1);

					DebugLocation(15, 57);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(15, 60);
					adaptor.AddChild(root_1, stream_idlist.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fdef", 2);
			LeaveRule("fdef", 2);
			LeaveRule_fdef();
		}
		DebugLocation(15, 66);
		} finally { DebugExitRule(GrammarFileName, "fdef"); }
		return retval;

	}
	// $ANTLR end "fdef"

	partial void EnterRule_stat();
	partial void LeaveRule_stat();
	// $ANTLR start "stat"
	// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:16:1: stat : ( 'if' expr stat -> ^( IF expr stat ) | 'while' expr stat -> ^( WHILE expr stat ) | 'return' expr ';' -> ^( RETURN expr ) | expr ';' -> ^( STANDALONE expr ) | ID '=' expr ';' -> ^( ASSIGN ID expr ) | '{' ( stat )* '}' -> ^( STATLIST ( stat )* ) | 'var' vdcl ( ',' vdcl )* ';' -> ( vdcl )+ | ';' ->);
	[GrammarRule("stat")]
	private AstParserRuleReturnScope<object, IToken> stat()
	{
		EnterRule_stat();
		EnterRule("stat", 3);
		TraceIn("stat", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal11 = default(IToken);
		IToken string_literal14 = default(IToken);
		IToken string_literal17 = default(IToken);
		IToken char_literal19 = default(IToken);
		IToken char_literal21 = default(IToken);
		IToken ID22 = default(IToken);
		IToken char_literal23 = default(IToken);
		IToken char_literal25 = default(IToken);
		IToken char_literal26 = default(IToken);
		IToken char_literal28 = default(IToken);
		IToken string_literal29 = default(IToken);
		IToken char_literal31 = default(IToken);
		IToken char_literal33 = default(IToken);
		IToken char_literal34 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr12 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> stat13 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr15 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> stat16 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr18 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr20 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr24 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> stat27 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> vdcl30 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> vdcl32 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal11_tree = default(object);
		object string_literal14_tree = default(object);
		object string_literal17_tree = default(object);
		object char_literal19_tree = default(object);
		object char_literal21_tree = default(object);
		object ID22_tree = default(object);
		object char_literal23_tree = default(object);
		object char_literal25_tree = default(object);
		object char_literal26_tree = default(object);
		object char_literal28_tree = default(object);
		object string_literal29_tree = default(object);
		object char_literal31_tree = default(object);
		object char_literal33_tree = default(object);
		object char_literal34_tree = default(object);
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleITokenStream stream_43=new RewriteRuleITokenStream(adaptor,"token 43");
		RewriteRuleITokenStream stream_37=new RewriteRuleITokenStream(adaptor,"token 37");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleITokenStream stream_46=new RewriteRuleITokenStream(adaptor,"token 46");
		RewriteRuleITokenStream stream_47=new RewriteRuleITokenStream(adaptor,"token 47");
		RewriteRuleITokenStream stream_44=new RewriteRuleITokenStream(adaptor,"token 44");
		RewriteRuleITokenStream stream_36=new RewriteRuleITokenStream(adaptor,"token 36");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		RewriteRuleSubtreeStream stream_stat=new RewriteRuleSubtreeStream(adaptor,"rule stat");
		RewriteRuleSubtreeStream stream_vdcl=new RewriteRuleSubtreeStream(adaptor,"rule vdcl");
		try { DebugEnterRule(GrammarFileName, "stat");
		DebugLocation(16, 45);
		try
		{
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:16:5: ( 'if' expr stat -> ^( IF expr stat ) | 'while' expr stat -> ^( WHILE expr stat ) | 'return' expr ';' -> ^( RETURN expr ) | expr ';' -> ^( STANDALONE expr ) | ID '=' expr ';' -> ^( ASSIGN ID expr ) | '{' ( stat )* '}' -> ^( STATLIST ( stat )* ) | 'var' vdcl ( ',' vdcl )* ';' -> ( vdcl )+ | ';' ->)
			int alt5=8;
			try { DebugEnterDecision(5, false);
			switch (input.LA(1))
			{
			case 42:
				{
				alt5 = 1;
				}
				break;
			case 45:
				{
				alt5 = 2;
				}
				break;
			case 43:
				{
				alt5 = 3;
				}
				break;
			case CHARLIT:
			case NOT:
			case NUMBER:
			case 34:
				{
				alt5 = 4;
				}
				break;
			case ID:
				{
				int LA5_2 = input.LA(2);

				if ((LA5_2==ASSIGN))
				{
					alt5 = 5;
				}
				else if (((LA5_2>=ADD && LA5_2<=AND)||LA5_2==EQ||LA5_2==GT||(LA5_2>=LT && LA5_2<=NEQ)||LA5_2==OR||LA5_2==SUB||LA5_2==34||LA5_2==37))
				{
					alt5 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 5, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 46:
				{
				alt5 = 6;
				}
				break;
			case 44:
				{
				alt5 = 7;
				}
				break;
			case 37:
				{
				alt5 = 8;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 5, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:16:7: 'if' expr stat
				{
				DebugLocation(16, 7);
				string_literal11=(IToken)Match(input,42,Follow._42_in_stat279); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_42.Add(string_literal11);

				DebugLocation(16, 12);
				PushFollow(Follow._expr_in_stat281);
				expr12=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(expr12.Tree);
				DebugLocation(16, 17);
				PushFollow(Follow._stat_in_stat283);
				stat13=stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_stat.Add(stat13.Tree);


				{
				// AST REWRITE
				// elements: expr, stat
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 16:43: -> ^( IF expr stat )
				{
					DebugLocation(16, 46);
					// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:16:46: ^( IF expr stat )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(16, 48);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(IF, "IF"), root_1);

					DebugLocation(16, 51);
					adaptor.AddChild(root_1, stream_expr.NextTree());
					DebugLocation(16, 56);
					adaptor.AddChild(root_1, stream_stat.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:17:7: 'while' expr stat
				{
				DebugLocation(17, 7);
				string_literal14=(IToken)Match(input,45,Follow._45_in_stat322); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_45.Add(string_literal14);

				DebugLocation(17, 15);
				PushFollow(Follow._expr_in_stat324);
				expr15=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(expr15.Tree);
				DebugLocation(17, 20);
				PushFollow(Follow._stat_in_stat326);
				stat16=stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_stat.Add(stat16.Tree);


				{
				// AST REWRITE
				// elements: expr, stat
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 17:43: -> ^( WHILE expr stat )
				{
					DebugLocation(17, 46);
					// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:17:46: ^( WHILE expr stat )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(17, 48);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(WHILE, "WHILE"), root_1);

					DebugLocation(17, 54);
					adaptor.AddChild(root_1, stream_expr.NextTree());
					DebugLocation(17, 59);
					adaptor.AddChild(root_1, stream_stat.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:18:7: 'return' expr ';'
				{
				DebugLocation(18, 7);
				string_literal17=(IToken)Match(input,43,Follow._43_in_stat362); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_43.Add(string_literal17);

				DebugLocation(18, 16);
				PushFollow(Follow._expr_in_stat364);
				expr18=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(expr18.Tree);
				DebugLocation(18, 21);
				char_literal19=(IToken)Match(input,37,Follow._37_in_stat366); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_37.Add(char_literal19);



				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 18:43: -> ^( RETURN expr )
				{
					DebugLocation(18, 46);
					// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:18:46: ^( RETURN expr )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(18, 48);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(RETURN, "RETURN"), root_1);

					DebugLocation(18, 55);
					adaptor.AddChild(root_1, stream_expr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:19:7: expr ';'
				{
				DebugLocation(19, 7);
				PushFollow(Follow._expr_in_stat400);
				expr20=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(expr20.Tree);
				DebugLocation(19, 12);
				char_literal21=(IToken)Match(input,37,Follow._37_in_stat402); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_37.Add(char_literal21);



				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 19:43: -> ^( STANDALONE expr )
				{
					DebugLocation(19, 46);
					// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:19:46: ^( STANDALONE expr )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(19, 48);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(STANDALONE, "STANDALONE"), root_1);

					DebugLocation(19, 59);
					adaptor.AddChild(root_1, stream_expr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:20:7: ID '=' expr ';'
				{
				DebugLocation(20, 7);
				ID22=(IToken)Match(input,ID,Follow._ID_in_stat445); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID22);

				DebugLocation(20, 10);
				char_literal23=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_stat447); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(char_literal23);

				DebugLocation(20, 14);
				PushFollow(Follow._expr_in_stat449);
				expr24=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(expr24.Tree);
				DebugLocation(20, 19);
				char_literal25=(IToken)Match(input,37,Follow._37_in_stat451); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_37.Add(char_literal25);



				{
				// AST REWRITE
				// elements: ID, expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 20:43: -> ^( ASSIGN ID expr )
				{
					DebugLocation(20, 46);
					// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:20:46: ^( ASSIGN ID expr )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(20, 48);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASSIGN, "ASSIGN"), root_1);

					DebugLocation(20, 55);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(20, 58);
					adaptor.AddChild(root_1, stream_expr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:21:7: '{' ( stat )* '}'
				{
				DebugLocation(21, 7);
				char_literal26=(IToken)Match(input,46,Follow._46_in_stat489); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_46.Add(char_literal26);

				DebugLocation(21, 11);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:21:11: ( stat )*
				try { DebugEnterSubRule(3);
				while (true)
				{
					int alt3=2;
					try { DebugEnterDecision(3, false);
					int LA3_1 = input.LA(1);

					if ((LA3_1==CHARLIT||LA3_1==ID||(LA3_1>=NOT && LA3_1<=NUMBER)||LA3_1==34||LA3_1==37||(LA3_1>=42 && LA3_1<=46)))
					{
						alt3 = 1;
					}


					} finally { DebugExitDecision(3); }
					switch ( alt3 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:21:11: stat
						{
						DebugLocation(21, 11);
						PushFollow(Follow._stat_in_stat491);
						stat27=stat();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_stat.Add(stat27.Tree);

						}
						break;

					default:
						goto loop3;
					}
				}

				loop3:
					;

				} finally { DebugExitSubRule(3); }

				DebugLocation(21, 17);
				char_literal28=(IToken)Match(input,47,Follow._47_in_stat494); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_47.Add(char_literal28);



				{
				// AST REWRITE
				// elements: stat
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 21:43: -> ^( STATLIST ( stat )* )
				{
					DebugLocation(21, 46);
					// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:21:46: ^( STATLIST ( stat )* )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(21, 48);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(STATLIST, "STATLIST"), root_1);

					DebugLocation(21, 57);
					// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:21:57: ( stat )*
					while ( stream_stat.HasNext )
					{
						DebugLocation(21, 57);
						adaptor.AddChild(root_1, stream_stat.NextTree());

					}
					stream_stat.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:22:4: 'var' vdcl ( ',' vdcl )* ';'
				{
				DebugLocation(22, 4);
				string_literal29=(IToken)Match(input,44,Follow._44_in_stat530); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_44.Add(string_literal29);

				DebugLocation(22, 10);
				PushFollow(Follow._vdcl_in_stat532);
				vdcl30=vdcl();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_vdcl.Add(vdcl30.Tree);
				DebugLocation(22, 15);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:22:15: ( ',' vdcl )*
				try { DebugEnterSubRule(4);
				while (true)
				{
					int alt4=2;
					try { DebugEnterDecision(4, false);
					int LA4_1 = input.LA(1);

					if ((LA4_1==36))
					{
						alt4 = 1;
					}


					} finally { DebugExitDecision(4); }
					switch ( alt4 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:22:16: ',' vdcl
						{
						DebugLocation(22, 16);
						char_literal31=(IToken)Match(input,36,Follow._36_in_stat535); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_36.Add(char_literal31);

						DebugLocation(22, 20);
						PushFollow(Follow._vdcl_in_stat537);
						vdcl32=vdcl();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_vdcl.Add(vdcl32.Tree);

						}
						break;

					default:
						goto loop4;
					}
				}

				loop4:
					;

				} finally { DebugExitSubRule(4); }

				DebugLocation(22, 27);
				char_literal33=(IToken)Match(input,37,Follow._37_in_stat541); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_37.Add(char_literal33);



				{
				// AST REWRITE
				// elements: vdcl
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 22:40: -> ( vdcl )+
				{
					DebugLocation(22, 45);
					if (!(stream_vdcl.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_vdcl.HasNext )
					{
						DebugLocation(22, 45);
						adaptor.AddChild(root_0, stream_vdcl.NextTree());

					}
					stream_vdcl.Reset();

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:23:7: ';'
				{
				DebugLocation(23, 7);
				char_literal34=(IToken)Match(input,37,Follow._37_in_stat565); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_37.Add(char_literal34);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 23:43: ->
				{
					DebugLocation(23, 46);
					root_0 = null;
				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stat", 3);
			LeaveRule("stat", 3);
			LeaveRule_stat();
		}
		DebugLocation(23, 45);
		} finally { DebugExitRule(GrammarFileName, "stat"); }
		return retval;

	}
	// $ANTLR end "stat"

	partial void EnterRule_vdcl();
	partial void LeaveRule_vdcl();
	// $ANTLR start "vdcl"
	// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:24:1: vdcl : ( ID ( '=' expr )? -> ^( VARDEF ID ) ( ^( ASSIGN ID expr ) )? | ID '[' NUMBER ']' -> ^( ARRDEF ID NUMBER ) );
	[GrammarRule("vdcl")]
	private AstParserRuleReturnScope<object, IToken> vdcl()
	{
		EnterRule_vdcl();
		EnterRule("vdcl", 4);
		TraceIn("vdcl", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID35 = default(IToken);
		IToken char_literal36 = default(IToken);
		IToken ID38 = default(IToken);
		IToken char_literal39 = default(IToken);
		IToken NUMBER40 = default(IToken);
		IToken char_literal41 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr37 = default(AstParserRuleReturnScope<object, IToken>);

		object ID35_tree = default(object);
		object char_literal36_tree = default(object);
		object ID38_tree = default(object);
		object char_literal39_tree = default(object);
		object NUMBER40_tree = default(object);
		object char_literal41_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleITokenStream stream_38=new RewriteRuleITokenStream(adaptor,"token 38");
		RewriteRuleITokenStream stream_NUMBER=new RewriteRuleITokenStream(adaptor,"token NUMBER");
		RewriteRuleITokenStream stream_39=new RewriteRuleITokenStream(adaptor,"token 39");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "vdcl");
		DebugLocation(24, 64);
		try
		{
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:24:5: ( ID ( '=' expr )? -> ^( VARDEF ID ) ( ^( ASSIGN ID expr ) )? | ID '[' NUMBER ']' -> ^( ARRDEF ID NUMBER ) )
			int alt7=2;
			try { DebugEnterDecision(7, false);
			int LA7_1 = input.LA(1);

			if ((LA7_1==ID))
			{
				int LA7_2 = input.LA(2);

				if ((LA7_2==38))
				{
					alt7 = 2;
				}
				else if ((LA7_2==ASSIGN||(LA7_2>=36 && LA7_2<=37)))
				{
					alt7 = 1;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 7, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 7, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:24:7: ID ( '=' expr )?
				{
				DebugLocation(24, 7);
				ID35=(IToken)Match(input,ID,Follow._ID_in_vdcl606); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID35);

				DebugLocation(24, 10);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:24:10: ( '=' expr )?
				int alt6=2;
				try { DebugEnterSubRule(6);
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1==ASSIGN))
				{
					alt6 = 1;
				}
				} finally { DebugExitDecision(6); }
				switch (alt6)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:24:11: '=' expr
					{
					DebugLocation(24, 11);
					char_literal36=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_vdcl609); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ASSIGN.Add(char_literal36);

					DebugLocation(24, 15);
					PushFollow(Follow._expr_in_vdcl611);
					expr37=expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expr.Add(expr37.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(6); }



				{
				// AST REWRITE
				// elements: ID, ID, expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 24:43: -> ^( VARDEF ID ) ( ^( ASSIGN ID expr ) )?
				{
					DebugLocation(24, 46);
					// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:24:46: ^( VARDEF ID )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(24, 48);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VARDEF, "VARDEF"), root_1);

					DebugLocation(24, 55);
					adaptor.AddChild(root_1, stream_ID.NextNode());

					adaptor.AddChild(root_0, root_1);
					}
					DebugLocation(24, 59);
					// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:24:59: ( ^( ASSIGN ID expr ) )?
					if (stream_ID.HasNext||stream_expr.HasNext)
					{
						DebugLocation(24, 59);
						// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:24:59: ^( ASSIGN ID expr )
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(24, 61);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASSIGN, "ASSIGN"), root_1);

						DebugLocation(24, 68);
						adaptor.AddChild(root_1, stream_ID.NextNode());
						DebugLocation(24, 71);
						adaptor.AddChild(root_1, stream_expr.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}
					stream_ID.Reset();
					stream_expr.Reset();

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:25:7: ID '[' NUMBER ']'
				{
				DebugLocation(25, 7);
				ID38=(IToken)Match(input,ID,Follow._ID_in_vdcl659); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID38);

				DebugLocation(25, 10);
				char_literal39=(IToken)Match(input,38,Follow._38_in_vdcl661); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_38.Add(char_literal39);

				DebugLocation(25, 14);
				NUMBER40=(IToken)Match(input,NUMBER,Follow._NUMBER_in_vdcl663); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NUMBER.Add(NUMBER40);

				DebugLocation(25, 21);
				char_literal41=(IToken)Match(input,39,Follow._39_in_vdcl665); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_39.Add(char_literal41);



				{
				// AST REWRITE
				// elements: ID, NUMBER
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 25:43: -> ^( ARRDEF ID NUMBER )
				{
					DebugLocation(25, 46);
					// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:25:46: ^( ARRDEF ID NUMBER )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(25, 48);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRDEF, "ARRDEF"), root_1);

					DebugLocation(25, 55);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(25, 58);
					adaptor.AddChild(root_1, stream_NUMBER.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("vdcl", 4);
			LeaveRule("vdcl", 4);
			LeaveRule_vdcl();
		}
		DebugLocation(25, 64);
		} finally { DebugExitRule(GrammarFileName, "vdcl"); }
		return retval;

	}
	// $ANTLR end "vdcl"

	partial void EnterRule_idlist();
	partial void LeaveRule_idlist();
	// $ANTLR start "idlist"
	// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:26:1: idlist : '(' ( ID ( ',' ID )* )? ')' -> ^( IDLIST ( ID )* ) ;
	[GrammarRule("idlist")]
	private AstParserRuleReturnScope<object, IToken> idlist()
	{
		EnterRule_idlist();
		EnterRule("idlist", 5);
		TraceIn("idlist", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal42 = default(IToken);
		IToken ID43 = default(IToken);
		IToken char_literal44 = default(IToken);
		IToken ID45 = default(IToken);
		IToken char_literal46 = default(IToken);

		object char_literal42_tree = default(object);
		object ID43_tree = default(object);
		object char_literal44_tree = default(object);
		object ID45_tree = default(object);
		object char_literal46_tree = default(object);
		RewriteRuleITokenStream stream_34=new RewriteRuleITokenStream(adaptor,"token 34");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_36=new RewriteRuleITokenStream(adaptor,"token 36");
		RewriteRuleITokenStream stream_35=new RewriteRuleITokenStream(adaptor,"token 35");
		try { DebugEnterRule(GrammarFileName, "idlist");
		DebugLocation(26, 58);
		try
		{
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:26:7: ( '(' ( ID ( ',' ID )* )? ')' -> ^( IDLIST ( ID )* ) )
			DebugEnterAlt(1);
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:26:11: '(' ( ID ( ',' ID )* )? ')'
			{
			DebugLocation(26, 11);
			char_literal42=(IToken)Match(input,34,Follow._34_in_idlist701); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_34.Add(char_literal42);

			DebugLocation(26, 15);
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:26:15: ( ID ( ',' ID )* )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_1 = input.LA(1);

			if ((LA9_1==ID))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:26:16: ID ( ',' ID )*
				{
				DebugLocation(26, 16);
				ID43=(IToken)Match(input,ID,Follow._ID_in_idlist704); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID43);

				DebugLocation(26, 19);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:26:19: ( ',' ID )*
				try { DebugEnterSubRule(8);
				while (true)
				{
					int alt8=2;
					try { DebugEnterDecision(8, false);
					int LA8_1 = input.LA(1);

					if ((LA8_1==36))
					{
						alt8 = 1;
					}


					} finally { DebugExitDecision(8); }
					switch ( alt8 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:26:20: ',' ID
						{
						DebugLocation(26, 20);
						char_literal44=(IToken)Match(input,36,Follow._36_in_idlist707); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_36.Add(char_literal44);

						DebugLocation(26, 24);
						ID45=(IToken)Match(input,ID,Follow._ID_in_idlist709); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_ID.Add(ID45);


						}
						break;

					default:
						goto loop8;
					}
				}

				loop8:
					;

				} finally { DebugExitSubRule(8); }


				}
				break;

			}
			} finally { DebugExitSubRule(9); }

			DebugLocation(26, 31);
			char_literal46=(IToken)Match(input,35,Follow._35_in_idlist715); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_35.Add(char_literal46);



			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 26:43: -> ^( IDLIST ( ID )* )
			{
				DebugLocation(26, 46);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:26:46: ^( IDLIST ( ID )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(26, 48);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(IDLIST, "IDLIST"), root_1);

				DebugLocation(26, 55);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:26:55: ( ID )*
				while ( stream_ID.HasNext )
				{
					DebugLocation(26, 55);
					adaptor.AddChild(root_1, stream_ID.NextNode());

				}
				stream_ID.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("idlist", 5);
			LeaveRule("idlist", 5);
			LeaveRule_idlist();
		}
		DebugLocation(26, 58);
		} finally { DebugExitRule(GrammarFileName, "idlist"); }
		return retval;

	}
	// $ANTLR end "idlist"

	partial void EnterRule_exprlist();
	partial void LeaveRule_exprlist();
	// $ANTLR start "exprlist"
	// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:27:1: exprlist : '(' ( expr ( ',' expr )* )? ')' -> ^( EXPRLIST ( expr )* ) ;
	[GrammarRule("exprlist")]
	private AstParserRuleReturnScope<object, IToken> exprlist()
	{
		EnterRule_exprlist();
		EnterRule("exprlist", 6);
		TraceIn("exprlist", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal47 = default(IToken);
		IToken char_literal49 = default(IToken);
		IToken char_literal51 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr48 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr50 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal47_tree = default(object);
		object char_literal49_tree = default(object);
		object char_literal51_tree = default(object);
		RewriteRuleITokenStream stream_34=new RewriteRuleITokenStream(adaptor,"token 34");
		RewriteRuleITokenStream stream_36=new RewriteRuleITokenStream(adaptor,"token 36");
		RewriteRuleITokenStream stream_35=new RewriteRuleITokenStream(adaptor,"token 35");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "exprlist");
		DebugLocation(27, 62);
		try
		{
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:27:9: ( '(' ( expr ( ',' expr )* )? ')' -> ^( EXPRLIST ( expr )* ) )
			DebugEnterAlt(1);
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:27:11: '(' ( expr ( ',' expr )* )? ')'
			{
			DebugLocation(27, 11);
			char_literal47=(IToken)Match(input,34,Follow._34_in_exprlist738); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_34.Add(char_literal47);

			DebugLocation(27, 15);
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:27:15: ( expr ( ',' expr )* )?
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_1 = input.LA(1);

			if ((LA11_1==CHARLIT||LA11_1==ID||(LA11_1>=NOT && LA11_1<=NUMBER)||LA11_1==34))
			{
				alt11 = 1;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:27:16: expr ( ',' expr )*
				{
				DebugLocation(27, 16);
				PushFollow(Follow._expr_in_exprlist741);
				expr48=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(expr48.Tree);
				DebugLocation(27, 21);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:27:21: ( ',' expr )*
				try { DebugEnterSubRule(10);
				while (true)
				{
					int alt10=2;
					try { DebugEnterDecision(10, false);
					int LA10_1 = input.LA(1);

					if ((LA10_1==36))
					{
						alt10 = 1;
					}


					} finally { DebugExitDecision(10); }
					switch ( alt10 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:27:22: ',' expr
						{
						DebugLocation(27, 22);
						char_literal49=(IToken)Match(input,36,Follow._36_in_exprlist744); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_36.Add(char_literal49);

						DebugLocation(27, 26);
						PushFollow(Follow._expr_in_exprlist746);
						expr50=expr();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_expr.Add(expr50.Tree);

						}
						break;

					default:
						goto loop10;
					}
				}

				loop10:
					;

				} finally { DebugExitSubRule(10); }


				}
				break;

			}
			} finally { DebugExitSubRule(11); }

			DebugLocation(27, 35);
			char_literal51=(IToken)Match(input,35,Follow._35_in_exprlist752); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_35.Add(char_literal51);



			{
			// AST REWRITE
			// elements: expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 27:43: -> ^( EXPRLIST ( expr )* )
			{
				DebugLocation(27, 46);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:27:46: ^( EXPRLIST ( expr )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(27, 48);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPRLIST, "EXPRLIST"), root_1);

				DebugLocation(27, 57);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:27:57: ( expr )*
				while ( stream_expr.HasNext )
				{
					DebugLocation(27, 57);
					adaptor.AddChild(root_1, stream_expr.NextTree());

				}
				stream_expr.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("exprlist", 6);
			LeaveRule("exprlist", 6);
			LeaveRule_exprlist();
		}
		DebugLocation(27, 62);
		} finally { DebugExitRule(GrammarFileName, "exprlist"); }
		return retval;

	}
	// $ANTLR end "exprlist"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();
	// $ANTLR start "atom"
	// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:28:1: atom : ( ( ID '(' )=> ID exprlist -> ^( FUNCALL ID exprlist ) | ID -> ^( VARNAME ID ) | NUMBER -> NUMBER | CHARLIT -> CHARLIT | '(' expr ')' -> expr );
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<object, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 7);
		TraceIn("atom", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID52 = default(IToken);
		IToken ID54 = default(IToken);
		IToken NUMBER55 = default(IToken);
		IToken CHARLIT56 = default(IToken);
		IToken char_literal57 = default(IToken);
		IToken char_literal59 = default(IToken);
		AstParserRuleReturnScope<object, IToken> exprlist53 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr58 = default(AstParserRuleReturnScope<object, IToken>);

		object ID52_tree = default(object);
		object ID54_tree = default(object);
		object NUMBER55_tree = default(object);
		object CHARLIT56_tree = default(object);
		object char_literal57_tree = default(object);
		object char_literal59_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_NUMBER=new RewriteRuleITokenStream(adaptor,"token NUMBER");
		RewriteRuleITokenStream stream_CHARLIT=new RewriteRuleITokenStream(adaptor,"token CHARLIT");
		RewriteRuleITokenStream stream_34=new RewriteRuleITokenStream(adaptor,"token 34");
		RewriteRuleITokenStream stream_35=new RewriteRuleITokenStream(adaptor,"token 35");
		RewriteRuleSubtreeStream stream_exprlist=new RewriteRuleSubtreeStream(adaptor,"rule exprlist");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(28, 51);
		try
		{
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:28:5: ( ( ID '(' )=> ID exprlist -> ^( FUNCALL ID exprlist ) | ID -> ^( VARNAME ID ) | NUMBER -> NUMBER | CHARLIT -> CHARLIT | '(' expr ')' -> expr )
			int alt12=5;
			try { DebugEnterDecision(12, false);
			switch (input.LA(1))
			{
			case ID:
				{
				int LA12_2 = input.LA(2);

				if ((EvaluatePredicate(synpred1_Clike_fragment)))
				{
					alt12 = 1;
				}
				else if ((true))
				{
					alt12 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 12, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case NUMBER:
				{
				alt12 = 3;
				}
				break;
			case CHARLIT:
				{
				alt12 = 4;
				}
				break;
			case 34:
				{
				alt12 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 12, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:28:7: ( ID '(' )=> ID exprlist
				{
				DebugLocation(28, 19);
				ID52=(IToken)Match(input,ID,Follow._ID_in_atom779); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID52);

				DebugLocation(28, 22);
				PushFollow(Follow._exprlist_in_atom781);
				exprlist53=exprlist();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_exprlist.Add(exprlist53.Tree);


				{
				// AST REWRITE
				// elements: ID, exprlist
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 28:43: -> ^( FUNCALL ID exprlist )
				{
					DebugLocation(28, 46);
					// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:28:46: ^( FUNCALL ID exprlist )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(28, 48);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCALL, "FUNCALL"), root_1);

					DebugLocation(28, 56);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(28, 59);
					adaptor.AddChild(root_1, stream_exprlist.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:29:7: ID
				{
				DebugLocation(29, 7);
				ID54=(IToken)Match(input,ID,Follow._ID_in_atom811); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID54);



				{
				// AST REWRITE
				// elements: ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 29:43: -> ^( VARNAME ID )
				{
					DebugLocation(29, 46);
					// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:29:46: ^( VARNAME ID )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(29, 48);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VARNAME, "VARNAME"), root_1);

					DebugLocation(29, 56);
					adaptor.AddChild(root_1, stream_ID.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:30:7: NUMBER
				{
				DebugLocation(30, 7);
				NUMBER55=(IToken)Match(input,NUMBER,Follow._NUMBER_in_atom860); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NUMBER.Add(NUMBER55);



				{
				// AST REWRITE
				// elements: NUMBER
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 30:43: -> NUMBER
				{
					DebugLocation(30, 48);
					adaptor.AddChild(root_0, stream_NUMBER.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:31:7: CHARLIT
				{
				DebugLocation(31, 7);
				CHARLIT56=(IToken)Match(input,CHARLIT,Follow._CHARLIT_in_atom903); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_CHARLIT.Add(CHARLIT56);



				{
				// AST REWRITE
				// elements: CHARLIT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 31:43: -> CHARLIT
				{
					DebugLocation(31, 48);
					adaptor.AddChild(root_0, stream_CHARLIT.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:32:7: '(' expr ')'
				{
				DebugLocation(32, 7);
				char_literal57=(IToken)Match(input,34,Follow._34_in_atom945); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_34.Add(char_literal57);

				DebugLocation(32, 11);
				PushFollow(Follow._expr_in_atom947);
				expr58=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(expr58.Tree);
				DebugLocation(32, 16);
				char_literal59=(IToken)Match(input,35,Follow._35_in_atom949); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_35.Add(char_literal59);



				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 32:43: -> expr
				{
					DebugLocation(32, 48);
					adaptor.AddChild(root_0, stream_expr.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom", 7);
			LeaveRule("atom", 7);
			LeaveRule_atom();
		}
		DebugLocation(32, 51);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();
	// $ANTLR start "expr"
	// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:34:1: expr : equ_expr ( ( AND | OR ) ^ equ_expr )* ;
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<object, IToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 8);
		TraceIn("expr", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set61 = default(IToken);
		AstParserRuleReturnScope<object, IToken> equ_expr60 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> equ_expr62 = default(AstParserRuleReturnScope<object, IToken>);

		object set61_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(34, 40);
		try
		{
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:34:5: ( equ_expr ( ( AND | OR ) ^ equ_expr )* )
			DebugEnterAlt(1);
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:34:11: equ_expr ( ( AND | OR ) ^ equ_expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(34, 11);
			PushFollow(Follow._equ_expr_in_expr995);
			equ_expr60=equ_expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, equ_expr60.Tree);
			DebugLocation(34, 20);
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:34:20: ( ( AND | OR ) ^ equ_expr )*
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=2;
				try { DebugEnterDecision(13, false);
				int LA13_1 = input.LA(1);

				if ((LA13_1==AND||LA13_1==OR))
				{
					alt13 = 1;
				}


				} finally { DebugExitDecision(13); }
				switch ( alt13 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:34:21: ( AND | OR ) ^ equ_expr
					{
					DebugLocation(34, 29);

					set61=(IToken)input.LT(1);
					set61=(IToken)input.LT(1);
					if (input.LA(1)==AND||input.LA(1)==OR)
					{
						input.Consume();
						if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set61), root_0);
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(34, 31);
					PushFollow(Follow._equ_expr_in_expr1005);
					equ_expr62=equ_expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, equ_expr62.Tree);

					}
					break;

				default:
					goto loop13;
				}
			}

			loop13:
				;

			} finally { DebugExitSubRule(13); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 8);
			LeaveRule("expr", 8);
			LeaveRule_expr();
		}
		DebugLocation(34, 40);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_equ_expr();
	partial void LeaveRule_equ_expr();
	// $ANTLR start "equ_expr"
	// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:35:1: equ_expr : cmp_expr ( ( EQ | NEQ ) ^ cmp_expr )* ;
	[GrammarRule("equ_expr")]
	private AstParserRuleReturnScope<object, IToken> equ_expr()
	{
		EnterRule_equ_expr();
		EnterRule("equ_expr", 9);
		TraceIn("equ_expr", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set64 = default(IToken);
		AstParserRuleReturnScope<object, IToken> cmp_expr63 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> cmp_expr65 = default(AstParserRuleReturnScope<object, IToken>);

		object set64_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "equ_expr");
		DebugLocation(35, 40);
		try
		{
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:35:9: ( cmp_expr ( ( EQ | NEQ ) ^ cmp_expr )* )
			DebugEnterAlt(1);
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:35:11: cmp_expr ( ( EQ | NEQ ) ^ cmp_expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(35, 11);
			PushFollow(Follow._cmp_expr_in_equ_expr1013);
			cmp_expr63=cmp_expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, cmp_expr63.Tree);
			DebugLocation(35, 20);
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:35:20: ( ( EQ | NEQ ) ^ cmp_expr )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_1 = input.LA(1);

				if ((LA14_1==EQ||LA14_1==NEQ))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:35:21: ( EQ | NEQ ) ^ cmp_expr
					{
					DebugLocation(35, 29);

					set64=(IToken)input.LT(1);
					set64=(IToken)input.LT(1);
					if (input.LA(1)==EQ||input.LA(1)==NEQ)
					{
						input.Consume();
						if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set64), root_0);
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(35, 31);
					PushFollow(Follow._cmp_expr_in_equ_expr1023);
					cmp_expr65=cmp_expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, cmp_expr65.Tree);

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equ_expr", 9);
			LeaveRule("equ_expr", 9);
			LeaveRule_equ_expr();
		}
		DebugLocation(35, 40);
		} finally { DebugExitRule(GrammarFileName, "equ_expr"); }
		return retval;

	}
	// $ANTLR end "equ_expr"

	partial void EnterRule_cmp_expr();
	partial void LeaveRule_cmp_expr();
	// $ANTLR start "cmp_expr"
	// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:36:1: cmp_expr : add_expr ( ( LT | GT ) ^ add_expr )* ;
	[GrammarRule("cmp_expr")]
	private AstParserRuleReturnScope<object, IToken> cmp_expr()
	{
		EnterRule_cmp_expr();
		EnterRule("cmp_expr", 10);
		TraceIn("cmp_expr", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set67 = default(IToken);
		AstParserRuleReturnScope<object, IToken> add_expr66 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> add_expr68 = default(AstParserRuleReturnScope<object, IToken>);

		object set67_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "cmp_expr");
		DebugLocation(36, 39);
		try
		{
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:36:9: ( add_expr ( ( LT | GT ) ^ add_expr )* )
			DebugEnterAlt(1);
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:36:11: add_expr ( ( LT | GT ) ^ add_expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(36, 11);
			PushFollow(Follow._add_expr_in_cmp_expr1031);
			add_expr66=add_expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, add_expr66.Tree);
			DebugLocation(36, 20);
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:36:20: ( ( LT | GT ) ^ add_expr )*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_1 = input.LA(1);

				if ((LA15_1==GT||LA15_1==LT))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:36:21: ( LT | GT ) ^ add_expr
					{
					DebugLocation(36, 28);

					set67=(IToken)input.LT(1);
					set67=(IToken)input.LT(1);
					if (input.LA(1)==GT||input.LA(1)==LT)
					{
						input.Consume();
						if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set67), root_0);
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(36, 30);
					PushFollow(Follow._add_expr_in_cmp_expr1041);
					add_expr68=add_expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, add_expr68.Tree);

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("cmp_expr", 10);
			LeaveRule("cmp_expr", 10);
			LeaveRule_cmp_expr();
		}
		DebugLocation(36, 39);
		} finally { DebugExitRule(GrammarFileName, "cmp_expr"); }
		return retval;

	}
	// $ANTLR end "cmp_expr"

	partial void EnterRule_add_expr();
	partial void LeaveRule_add_expr();
	// $ANTLR start "add_expr"
	// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:37:1: add_expr : mul_expr ( ( ADD | SUB ) ^ mul_expr )* ;
	[GrammarRule("add_expr")]
	private AstParserRuleReturnScope<object, IToken> add_expr()
	{
		EnterRule_add_expr();
		EnterRule("add_expr", 11);
		TraceIn("add_expr", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set70 = default(IToken);
		AstParserRuleReturnScope<object, IToken> mul_expr69 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> mul_expr71 = default(AstParserRuleReturnScope<object, IToken>);

		object set70_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "add_expr");
		DebugLocation(37, 41);
		try
		{
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:37:9: ( mul_expr ( ( ADD | SUB ) ^ mul_expr )* )
			DebugEnterAlt(1);
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:37:11: mul_expr ( ( ADD | SUB ) ^ mul_expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(37, 11);
			PushFollow(Follow._mul_expr_in_add_expr1049);
			mul_expr69=mul_expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, mul_expr69.Tree);
			DebugLocation(37, 20);
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:37:20: ( ( ADD | SUB ) ^ mul_expr )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_1 = input.LA(1);

				if ((LA16_1==ADD||LA16_1==SUB))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:37:21: ( ADD | SUB ) ^ mul_expr
					{
					DebugLocation(37, 30);

					set70=(IToken)input.LT(1);
					set70=(IToken)input.LT(1);
					if (input.LA(1)==ADD||input.LA(1)==SUB)
					{
						input.Consume();
						if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set70), root_0);
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(37, 32);
					PushFollow(Follow._mul_expr_in_add_expr1059);
					mul_expr71=mul_expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, mul_expr71.Tree);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("add_expr", 11);
			LeaveRule("add_expr", 11);
			LeaveRule_add_expr();
		}
		DebugLocation(37, 41);
		} finally { DebugExitRule(GrammarFileName, "add_expr"); }
		return retval;

	}
	// $ANTLR end "add_expr"

	partial void EnterRule_mul_expr();
	partial void LeaveRule_mul_expr();
	// $ANTLR start "mul_expr"
	// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:38:1: mul_expr : neg_expr ( MUL ^ neg_expr )* ;
	[GrammarRule("mul_expr")]
	private AstParserRuleReturnScope<object, IToken> mul_expr()
	{
		EnterRule_mul_expr();
		EnterRule("mul_expr", 12);
		TraceIn("mul_expr", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken MUL73 = default(IToken);
		AstParserRuleReturnScope<object, IToken> neg_expr72 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> neg_expr74 = default(AstParserRuleReturnScope<object, IToken>);

		object MUL73_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "mul_expr");
		DebugLocation(38, 35);
		try
		{
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:38:9: ( neg_expr ( MUL ^ neg_expr )* )
			DebugEnterAlt(1);
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:38:11: neg_expr ( MUL ^ neg_expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(38, 11);
			PushFollow(Follow._neg_expr_in_mul_expr1067);
			neg_expr72=neg_expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, neg_expr72.Tree);
			DebugLocation(38, 20);
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:38:20: ( MUL ^ neg_expr )*
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=2;
				try { DebugEnterDecision(17, false);
				int LA17_1 = input.LA(1);

				if ((LA17_1==MUL))
				{
					alt17 = 1;
				}


				} finally { DebugExitDecision(17); }
				switch ( alt17 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:38:21: MUL ^ neg_expr
					{
					DebugLocation(38, 24);
					MUL73=(IToken)Match(input,MUL,Follow._MUL_in_mul_expr1070); if (state.failed) return retval;
					if (state.backtracking == 0) {
					MUL73_tree = (object)adaptor.Create(MUL73);
					root_0 = (object)adaptor.BecomeRoot(MUL73_tree, root_0);
					}
					DebugLocation(38, 26);
					PushFollow(Follow._neg_expr_in_mul_expr1073);
					neg_expr74=neg_expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, neg_expr74.Tree);

					}
					break;

				default:
					goto loop17;
				}
			}

			loop17:
				;

			} finally { DebugExitSubRule(17); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("mul_expr", 12);
			LeaveRule("mul_expr", 12);
			LeaveRule_mul_expr();
		}
		DebugLocation(38, 35);
		} finally { DebugExitRule(GrammarFileName, "mul_expr"); }
		return retval;

	}
	// $ANTLR end "mul_expr"

	partial void EnterRule_neg_expr();
	partial void LeaveRule_neg_expr();
	// $ANTLR start "neg_expr"
	// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:39:1: neg_expr : ( ( NOT ^ atom ) | atom );
	[GrammarRule("neg_expr")]
	private AstParserRuleReturnScope<object, IToken> neg_expr()
	{
		EnterRule_neg_expr();
		EnterRule("neg_expr", 13);
		TraceIn("neg_expr", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NOT75 = default(IToken);
		AstParserRuleReturnScope<object, IToken> atom76 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> atom77 = default(AstParserRuleReturnScope<object, IToken>);

		object NOT75_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "neg_expr");
		DebugLocation(39, 28);
		try
		{
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:39:9: ( ( NOT ^ atom ) | atom )
			int alt18=2;
			try { DebugEnterDecision(18, false);
			int LA18_1 = input.LA(1);

			if ((LA18_1==NOT))
			{
				alt18 = 1;
			}
			else if ((LA18_1==CHARLIT||LA18_1==ID||LA18_1==NUMBER||LA18_1==34))
			{
				alt18 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 18, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:39:11: ( NOT ^ atom )
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(39, 11);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:39:11: ( NOT ^ atom )
				DebugEnterAlt(1);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:39:12: NOT ^ atom
				{
				DebugLocation(39, 15);
				NOT75=(IToken)Match(input,NOT,Follow._NOT_in_neg_expr1082); if (state.failed) return retval;
				if (state.backtracking == 0) {
				NOT75_tree = (object)adaptor.Create(NOT75);
				root_0 = (object)adaptor.BecomeRoot(NOT75_tree, root_0);
				}
				DebugLocation(39, 17);
				PushFollow(Follow._atom_in_neg_expr1085);
				atom76=atom();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, atom76.Tree);

				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:39:25: atom
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(39, 25);
				PushFollow(Follow._atom_in_neg_expr1090);
				atom77=atom();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, atom77.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("neg_expr", 13);
			LeaveRule("neg_expr", 13);
			LeaveRule_neg_expr();
		}
		DebugLocation(39, 28);
		} finally { DebugExitRule(GrammarFileName, "neg_expr"); }
		return retval;

	}
	// $ANTLR end "neg_expr"

	partial void EnterRule_synpred1_Clike_fragment();
	partial void LeaveRule_synpred1_Clike_fragment();

	// $ANTLR start synpred1_Clike
	private void synpred1_Clike_fragment()
	{
		EnterRule_synpred1_Clike_fragment();
		EnterRule("synpred1_Clike_fragment", 14);
		TraceIn("synpred1_Clike_fragment", 14);
		try
		{
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:28:7: ( ID '(' )
			DebugEnterAlt(1);
			// D:\\Projects\\C#\\PseudoBF\\PseudoBF\\Frontend\\C\\Clike.g:28:8: ID '('
			{
			DebugLocation(28, 8);
			Match(input,ID,Follow._ID_in_synpred1_Clike772); if (state.failed) return;
			DebugLocation(28, 11);
			Match(input,34,Follow._34_in_synpred1_Clike774); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_Clike_fragment", 14);
			LeaveRule("synpred1_Clike_fragment", 14);
			LeaveRule_synpred1_Clike_fragment();
		}
	}
	// $ANTLR end synpred1_Clike
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _fdef_in_program170 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_program173 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _41_in_fdef204 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _ID_in_fdef206 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _idlist_in_fdef208 = new BitSet(new ulong[]{0x7C2400C10100UL});
		public static readonly BitSet _stat_in_fdef210 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _40_in_fdef244 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _ID_in_fdef246 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _idlist_in_fdef248 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _37_in_fdef250 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _42_in_stat279 = new BitSet(new ulong[]{0x400C10100UL});
		public static readonly BitSet _expr_in_stat281 = new BitSet(new ulong[]{0x7C2400C10100UL});
		public static readonly BitSet _stat_in_stat283 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _45_in_stat322 = new BitSet(new ulong[]{0x400C10100UL});
		public static readonly BitSet _expr_in_stat324 = new BitSet(new ulong[]{0x7C2400C10100UL});
		public static readonly BitSet _stat_in_stat326 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _43_in_stat362 = new BitSet(new ulong[]{0x400C10100UL});
		public static readonly BitSet _expr_in_stat364 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _37_in_stat366 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_stat400 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _37_in_stat402 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_stat445 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _ASSIGN_in_stat447 = new BitSet(new ulong[]{0x400C10100UL});
		public static readonly BitSet _expr_in_stat449 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _37_in_stat451 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _46_in_stat489 = new BitSet(new ulong[]{0xFC2400C10100UL});
		public static readonly BitSet _stat_in_stat491 = new BitSet(new ulong[]{0xFC2400C10100UL});
		public static readonly BitSet _47_in_stat494 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _44_in_stat530 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _vdcl_in_stat532 = new BitSet(new ulong[]{0x3000000000UL});
		public static readonly BitSet _36_in_stat535 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _vdcl_in_stat537 = new BitSet(new ulong[]{0x3000000000UL});
		public static readonly BitSet _37_in_stat541 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _37_in_stat565 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_vdcl606 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _ASSIGN_in_vdcl609 = new BitSet(new ulong[]{0x400C10100UL});
		public static readonly BitSet _expr_in_vdcl611 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_vdcl659 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _38_in_vdcl661 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _NUMBER_in_vdcl663 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _39_in_vdcl665 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _34_in_idlist701 = new BitSet(new ulong[]{0x800010000UL});
		public static readonly BitSet _ID_in_idlist704 = new BitSet(new ulong[]{0x1800000000UL});
		public static readonly BitSet _36_in_idlist707 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _ID_in_idlist709 = new BitSet(new ulong[]{0x1800000000UL});
		public static readonly BitSet _35_in_idlist715 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _34_in_exprlist738 = new BitSet(new ulong[]{0xC00C10100UL});
		public static readonly BitSet _expr_in_exprlist741 = new BitSet(new ulong[]{0x1800000000UL});
		public static readonly BitSet _36_in_exprlist744 = new BitSet(new ulong[]{0x400C10100UL});
		public static readonly BitSet _expr_in_exprlist746 = new BitSet(new ulong[]{0x1800000000UL});
		public static readonly BitSet _35_in_exprlist752 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_atom779 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _exprlist_in_atom781 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_atom811 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NUMBER_in_atom860 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHARLIT_in_atom903 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _34_in_atom945 = new BitSet(new ulong[]{0x400C10100UL});
		public static readonly BitSet _expr_in_atom947 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _35_in_atom949 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _equ_expr_in_expr995 = new BitSet(new ulong[]{0x1000022UL});
		public static readonly BitSet _set_in_expr998 = new BitSet(new ulong[]{0x400C10100UL});
		public static readonly BitSet _equ_expr_in_expr1005 = new BitSet(new ulong[]{0x1000022UL});
		public static readonly BitSet _cmp_expr_in_equ_expr1013 = new BitSet(new ulong[]{0x200402UL});
		public static readonly BitSet _set_in_equ_expr1016 = new BitSet(new ulong[]{0x400C10100UL});
		public static readonly BitSet _cmp_expr_in_equ_expr1023 = new BitSet(new ulong[]{0x200402UL});
		public static readonly BitSet _add_expr_in_cmp_expr1031 = new BitSet(new ulong[]{0x88002UL});
		public static readonly BitSet _set_in_cmp_expr1034 = new BitSet(new ulong[]{0x400C10100UL});
		public static readonly BitSet _add_expr_in_cmp_expr1041 = new BitSet(new ulong[]{0x88002UL});
		public static readonly BitSet _mul_expr_in_add_expr1049 = new BitSet(new ulong[]{0x20000012UL});
		public static readonly BitSet _set_in_add_expr1052 = new BitSet(new ulong[]{0x400C10100UL});
		public static readonly BitSet _mul_expr_in_add_expr1059 = new BitSet(new ulong[]{0x20000012UL});
		public static readonly BitSet _neg_expr_in_mul_expr1067 = new BitSet(new ulong[]{0x100002UL});
		public static readonly BitSet _MUL_in_mul_expr1070 = new BitSet(new ulong[]{0x400C10100UL});
		public static readonly BitSet _neg_expr_in_mul_expr1073 = new BitSet(new ulong[]{0x100002UL});
		public static readonly BitSet _NOT_in_neg_expr1082 = new BitSet(new ulong[]{0x400810100UL});
		public static readonly BitSet _atom_in_neg_expr1085 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _atom_in_neg_expr1090 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred1_Clike772 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_synpred1_Clike774 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
